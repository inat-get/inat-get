# Модель конкурентности inat-get

## Архитектура процессов

Главный процесс (inat-get) запускает:
- API-сервер (1 процесс, single-threaded)
- Console-сервер (1 процесс, single-threaded)
- Worker-процессы (до N параллельно, N = config[:workers][:limit])

Все процессы связаны через UNIX-domain sockets. Никакого shared memory, координация только через БД.

## API-сервер

**Ответственность**: rate limiting, HTTP-клиент к iNaturalist.

**Модель**: бесконечный цикл `accept → read → sleep(остаток_до_следующего_разрешённого) → HTTP → send → close`. 
Строго последовательная обработка, FIFO. Пауза `@delay` выдерживается между **началом** предыдущего и **началом** следующего запроса.

**Состояние**: `@last_request` — время начала последнего HTTP-запроса. Не персистентно, 
при рестарте возможен burst (допустим при rate limit 60 req/min и delay 1s).

## Console-сервер

**Ответственность**: терминальный UI (is-term) и файловое логирование.

**Модель**: `accept → read → обновить таблицу/записать лог → send (опционально) → close`.

Является bottleneck только при крайне частых лог-сообщениях (не ожидается).

## Worker-процессы

**Жизненный цикл**:
1. Fork от главного процесса
2. `register` в Console
3. `prepare` — создать DB-соединение (Sequel)
4. `execute` — выполнить task-скрипт
5. `update _active: false` в Console
6. Завершение

**Соединения**: каждый воркер имеет своё `Sequel::Database`. Никакого пула, 
транзакции изолированы на уровне SQLite/БД.

**Запуск**: первые N воркеров стартуют почти одновременно, далее по мере завершения.

## Обработка отказов

| Сценарий | Поведение | Статус |
|----------|-----------|--------|
| Исключение в воркере | `rescue → log error → _active: false` | Реализовано |
| SIGKILL / OOM воркера | Console показывает "зависший" процесс | Limitation: не отслеживается |
| Падение API-сервера | Воркеры блокируются на `api.get` | Требует рестарта скрипта |
| Падение Console-сервера | Логирование в stderr? | Не определено |

## Graceful shutdown (planned)

При SIGINT/SIGTERM:
1. Перестать запускать новых воркеров
2. Дождаться завершения текущих (таймаут?)
3. `:quit` → API-сервер, Console-сервер
4. Удалить сокеты, выйти

## Security

- Директория сокетов: `chmod 0700`, возможно включение UID в путь
- Sticky bit `/tmp` не защищает от подмены директории другим пользователем

## Известные ограничения

1. **Head-of-line blocking**: тяжёлый API-запрос блокирует лёгкие
2. **No request timeouts**: воркер ждёт ответа API неограниченно
3. **Race на Request**: при коллизии hash — INSERT + rescue UniqueConstraint (лишние запросы)
4. **Burst при рестарте API**: теряется `@last_request`, возможен burst
5. **SIGKILL невидим**: Console не узнаёт о насильственном завершении воркера
