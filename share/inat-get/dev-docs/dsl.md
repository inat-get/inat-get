# DSL iNatGet

## Общие принципы

Скрипты `*.inat` представляют собой обычные Ruby-скрипты с предзагруженными методами DSL. Пользователь пишет на полноценном Ruby, но в распоряжении имеет набор специализированных методов для работы с данными iNaturalist.

Основные принципы DSL:

- **Ленивость**: никакие операции не приводят к немедленному обращению к API или БД
- **Композиционность**: сложные запросы строятся из простых через операции над датасетами
- **Непрозрачность кэширования**: пользователь не управляет кэшем явно, система сама решает, когда обновлять данные
- **Изоляция**: прямой доступ к классам моделей и внутренним механизмам не требуется и не предоставляется

---

## Датасеты (Dataset)

Датасет — ленивое представление набора наблюдений или таксонов с прикреплённым условием отбора. Условие не выполняется до тех пор, пока не потребуется доступ к данным.

### Создание датасетов

| Метод | Возвращает | Описание |
|-------|-----------|----------|
| `observations(**query)` | `Dataset` | Набор наблюдений по условию |
| `taxa(**query)` | `Dataset` | Набор таксонов по условию |
| `observation(id)` | `Observation` \| `nil` | Одно наблюдение по ID |
| `taxon(id)` | `Taxon` \| `nil` | Один таксон по ID |

Методы `place`, `project`, `user` возвращают не датасеты, а отдельные модели Sequel. Для включения в условия датасетов они используются неявно через параметры запроса.

### Параметры запроса для observations

| Параметр | Тип | Описание |
|----------|-----|----------|
| `taxon` | Taxon, Integer, Set[Taxon], Set[Integer] | Таксон или множество таксонов (включая потомков) |
| `place` | Place, Integer, String, Set[...] | Место по объекту, ID или slug |
| `user` | User, Integer, String, Set[...] | Пользователь по объекту, ID или login |
| `project` | Project, Integer, String, Set[...] | Проект по объекту, ID или slug |
| `rank` | Rank, Range[Rank], Set[Rank] | Ранг таксона (species, genus и т.д.) |
| `quality_grade` | String, Symbol, Set[...] | Качество (research, needs_id, casual) |
| `captive`, `mappable`, `threatened`, `introduced` и др. | Boolean | Флаги наблюдений |
| `observed`, `created` | Time, Date, Range[Time] | Временные диапазоны |
| `latitude`, `longitude` | Float, Range[Float] | Географические координаты |
| `location` | [Float, Float] | Точка [lat, lon] для поиска в радиусе |
| `radius` | Float | Радиус в километрах для `location` |
| `license`, `photo_license`, `sound_license` | String, Symbol, Set[...] | Лицензии |
| `geoprivacy`, `taxon_geoprivacy` | String, Symbol, Set[...] | Приватность геоданных |
| `id`, `observed_year`, `observed_month` и др. | Integer, Set[Integer], Range[Integer] | Идентификаторы и временные компоненты |

Полный список см. в `lib/inat-get/data/helper.rb`.

### Параметры запроса для taxa

| Параметр | Тип | Описание |
|----------|-----|----------|
| `id` | Integer, Set[Integer] | ID таксона |
| `parent` | Taxon, Integer | Родительский таксон |
| `is_active` | Boolean | Активен ли таксон |
| `rank` | Rank, Range[Rank], Set[Rank] | Ранг |

---

## Операции над датасетами

Все операции требуют совместимости операндов: оба датасета должны иметь один и тот же helper (то есть относиться к одному типу сущностей — observations или taxa). Несовместимые операнды вызывают исключение.

| Оператор | Семантика | Результат |
|----------|-----------|-----------|
| `ds1 + ds2` | Объединение | Датасет с условием ИЛИ |
| `ds1 * ds2` | Пересечение | Датасет с условием И |
| `ds1 - ds2` | Разность | Датасет с условием И-НЕ |

Алгебраические свойства:
- `+` коммутативен и ассоциативен
- `*` коммутативен и ассоциативен  
- `-` не коммутативен
- Приоритет: стандартный для Ruby (`*` выше `+`)

### Операция разбиения

`ds % field` — разбивает датасет на подмножества по значению поля.

Возвращает `List` — отображение значение поля → датасет с соответствующим ограничением.

```ruby
# Разбиение наблюдений птиц по пользователям
by_user = observations(taxon: taxon_birds) % :user

# Итерация по парам [user, dataset]
by_user.each do |user, ds|
  puts "#{user.login}: #{ds.count} наблюдений"
end
```

**Ограничения текущей реализации**: разбиение материализует полный список ключей (пользователей) при создании. Ленивое разбиение запланировано на будущее.

---

## Списки (List)

`List` — контейнер для набора датасетов с однородными ключами. Не путать с Ruby Array.

### Операции над списками

| Оператор | Семантика | Описание |
|----------|-----------|----------|
| `list + other` | Объединение | По ключам: ключ присутствует, если есть в любом списке; датасеты для общих ключей объединяются |
| `list * other` | Пересечение | По ключам: ключ присутствует, если есть в обоих списках; датасеты для общих ключей также объединяются |
| `list - other` | Разность | По ключам: ключи из other удаляются вместе с датасетами |
| `list.to_ds` | Свертка | Объединяет все датасеты списка в один через ИЛИ |

Требование однородности ключей: операции над списками с несовпадающими типами ключей вызывают исключение.

---

## Материализация и итерация

Датасет становится "материализованным" при первом обращении к данным:

| Метод | Действие |
|-------|----------|
| `ds.each { \|item\| ... }` | Итерация по записям |
| `ds.count` | Подсчёт записей (оптимизированно на уровне SQL) |
| `ds.first` | Первая запись |
| `ds.to_a` | Массив всех записей (осторожно с большими наборами!) |

При материализации:
1. Вызывается `update!` — проверка необходимости обновления данных из API
2. Условие транслируется в SQL через Sequel
3. Выполняется запрос к локальной БД

**Важно**: материализация одного датасета не влияет на другие, даже если они перекрываются по условиям. Каждый датасет независим.

---

## Кэширование и обновление данных

Пользователь не управляет кэшем явно. Система автоматически определяет, нужно ли обращаться к API iNaturalist.

### Автоматическое поведение

- При первой материализации датасета проверяется актуальность данных по правилам, описанным в `caching.md`
- Если данные устарели — выполняется запрос к API с учётом кэшированных предыдущих запросов
- В рамках одного выполнения скрипта кэш считается неизменным

### Явные методы (используются редко)

| Метод | Действие |
|-------|----------|
| `ds.update!` | Форсирует проверку необходимости обновления данных. Не всегда приводит к API-запросу — только если данные устарели по правилам кэширования |
| `ds.reset!` | Сбрасывает состояние материализации датасета. Следующая итерация снова вызовет `update!` |

Нет способа принудительно игнорировать локальный кэск. Для отладки или получения "чистых" данных следует использовать `--db-reset` или удалить файл БД.

---

## Граничные случаи и ограничения

### Неподдерживаемые в API условия

iNaturalist API имеет ограниченный набор фильтров. В частности, отрицания (NOT) напрямую не поддерживаются.

При нормализации условий:
- Отрицания максимально сокращаются и проталкиваются к листьям
- Оставшиеся отрицания игнорируются при формировании API-запроса
- Данные загружаются в расширенном объёме, финальная фильтрация выполняется в БД

Пример:
```ruby
# Загружаются все наблюдения птиц, при итерации фильтруются
observations(taxon: taxon_birds) - observations(user: current_user)
```

### Критическое ограничение: неограниченные запросы

Датасет с условием, эквивалентным "всё" (ANYTHING), не может быть материализован — генерируется исключение. Это защита от попыток загрузить всю базу iNaturalist.

Недопустимые конструкции:
```ruby
observations()  # пустой запрос
observations(taxon: taxon_birds) + observations()  # OR с чем угодно = что угодно
```

Допустимые пустые результаты:
```ruby
observations(taxon: taxon_birds) * observations(taxon: taxon_mammals)  # NOTHING
```
Результат — пустой датасет, ошибки нет.

---

## Примеры использования

### Базовая фильтрация

```ruby
# Наблюдения птиц в России
birds_in_russia = observations(taxon: taxon_birds, place: place_russia)

# Исследовательского качества
research_grade = birds_in_russia * observations(quality_grade: :research)

# За последний год
recent = research_grade * observations(observed: (today - 365)..today)

recent.each do |obs|
  puts "#{obs.taxon.name}: #{obs.observed}"
end
```

### Разбиение и агрегация

```ruby
# Топ-10 пользователей по количеству наблюдений птиц
by_user = observations(taxon: taxon_birds) % :user

counts = by_user.map { |user, ds| [user, ds.count] }
top10 = counts.sort_by { |_, count| -count }.first(10)

top10.each do |user, count|
  puts "#{user.login}: #{count}"
end
```

### Комбинирование условий

```ruby
# Птицы или млекопитающие, но только исследовательского качества
birds = observations(taxon: taxon_birds)
mammals = observations(taxon: taxon_mammals)
research = observations(quality_grade: :research)

target = (birds + mammals) * research
```

---

## Открытые вопросы и планы

| Функциональность | Статус | Примечание |
|------------------|--------|------------|
| Ленивое разбиение (`%`) | Запланировано | Текущая реализация материализует ключи |
| Категория "всё остальное" в разбиении | Не рассмотрено | Нет ясного use-case |
| Агрегации без materialize | Не требуется | Обход через `% + map` достаточен |
| Параллельное выполнение OR-веток | Отклонено | Rate limits API не позволяют |
| Изоляция DSL для встраивания в другие Ruby-скрипты | Требует проработки | Зависимость от окружения Task |
| Тестирование скриптов `.inat` | Не планируется | Вне scope проекта |
